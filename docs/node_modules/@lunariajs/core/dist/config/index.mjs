import { readFileSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { error } from '../cli/console.mjs';
import { r as removeTrailingSlash, i as isRelative, l as loadWithJiti } from '../shared/core.47b71d59.mjs';
import { z } from 'zod';
import '@clack/core';
import 'picocolors';
import { D as DashboardSchema } from '../shared/core.69eed5f0.mjs';
import 'node:module';

const errorMap = (baseError, ctx) => {
  const baseErrorPath = flattenErrorPath(baseError.path);
  if (baseError.code === "invalid_union") {
    let typeOrLiteralErrByPath = /* @__PURE__ */ new Map();
    for (const unionError of baseError.unionErrors.map((e) => e.errors).flat()) {
      if (unionError.code === "invalid_type" || unionError.code === "invalid_literal") {
        const flattenedErrorPath = flattenErrorPath(unionError.path);
        if (typeOrLiteralErrByPath.has(flattenedErrorPath)) {
          typeOrLiteralErrByPath.get(flattenedErrorPath).expected.push(unionError.expected);
        } else {
          typeOrLiteralErrByPath.set(flattenedErrorPath, {
            code: unionError.code,
            received: unionError.received,
            expected: [unionError.expected]
          });
        }
      }
    }
    const messages = [prefix(baseErrorPath, "Did not match union.")];
    const details = [...typeOrLiteralErrByPath.entries()].filter(([, error]) => error.expected.length === baseError.unionErrors.length).map(
      ([key, error]) => key === baseErrorPath ? (
        // Avoid printing the key again if it's a base error.
        `> ${getTypeOrLiteralMsg(error)}`
      ) : `> ${prefix(key, getTypeOrLiteralMsg(error))}`
    );
    if (details.length === 0) {
      const expectedShapes = [];
      for (const unionError of baseError.unionErrors) {
        const expectedShape = [];
        for (const issue of unionError.issues) {
          if (issue.code === "invalid_union") {
            return errorMap(issue, ctx);
          }
          const relativePath = flattenErrorPath(issue.path).replace(baseErrorPath, "").replace(leadingPeriod, "");
          if ("expected" in issue && typeof issue.expected === "string") {
            expectedShape.push(
              relativePath ? `${relativePath}: ${issue.expected}` : issue.expected
            );
          } else {
            expectedShape.push(relativePath);
          }
        }
        expectedShapes.push(`{ ${expectedShape.join("; ")} }`);
      }
      if (expectedShapes.length) {
        details.push("> Expected type `" + expectedShapes.join(" | ") + "`");
        details.push("> Received `" + stringify(ctx.data) + "`");
      }
    }
    return {
      message: messages.concat(details).join("\n")
    };
  } else if (baseError.code === "invalid_literal" || baseError.code === "invalid_type") {
    return {
      message: prefix(
        baseErrorPath,
        getTypeOrLiteralMsg({
          code: baseError.code,
          received: baseError.received,
          expected: [baseError.expected]
        })
      )
    };
  } else if (baseError.message) {
    return { message: prefix(baseErrorPath, baseError.message) };
  } else {
    return { message: prefix(baseErrorPath, ctx.defaultError) };
  }
};
const getTypeOrLiteralMsg = (error) => {
  if (error.received === "undefined")
    return "Required";
  const expectedDeduped = new Set(error.expected);
  switch (error.code) {
    case "invalid_type":
      return `Expected type \`${unionExpectedVals(expectedDeduped)}\`, received \`${stringify(
        error.received
      )}\``;
    case "invalid_literal":
      return `Expected \`${unionExpectedVals(expectedDeduped)}\`, received \`${stringify(
        error.received
      )}\``;
  }
};
const prefix = (key, msg) => key.length ? `${key}: ${msg}` : msg;
const unionExpectedVals = (expectedVals) => [...expectedVals].map((expectedVal) => stringify(expectedVal)).join(" | ");
const flattenErrorPath = (errorPath) => errorPath.join(".");
const stringify = (val) => JSON.stringify(val, null, 1).split(newlinePlusWhitespace).join(" ");
const newlinePlusWhitespace = /\n\s*/;
const leadingPeriod = /^\./;

const RepositorySchema = z.object({
  /** The unique name of your repository in your git hosting platform, e.g. `"Yan-Thomas/lunaria"` */
  name: z.string().transform((path) => removeTrailingSlash(path)).describe(
    'The unique name of your repository in your git hosting platform, e.g. `"Yan-Thomas/lunaria"`'
  ),
  /** The currently tracked branch of your repository */
  branch: z.string().default("main").describe("The currently tracked branch of your repository"),
  /** The root directory of the project being tracked, must be set when using a monorepo */
  rootDir: z.string().default(".").refine((path) => !isRelative(path), {
    message: "The root directory should not be a relative path, it should follow the example: `examples/vitepress`"
  }).transform((path) => removeTrailingSlash(path)).describe("The root directory of the project being tracked, must be set when using a monorepo"),
  /** The git hosting platform used by your project, e.g. `"github"` or `"gitlab"` */
  hosting: z.literal("github").or(z.literal("gitlab")).default("github").describe('The git hosting platform used by your project, e.g. `"github"` or `"gitlab"`')
});
const OptionalKeysSchema = z.record(z.string(), z.array(z.string())).describe(
  "Record of dictionary shared paths whose values are an array of dictionary keys to be marked as optional"
);
const BaseFileSchema = z.object({
  /** The glob pattern of where your content including the file type(s) is */
  location: z.string().describe(
    'The glob pattern of where your content including the file type(s) is, e.g. `"src/content/docs/**/*.mdx"`'
  ),
  /** Array of glob patterns to be ignored from matching */
  ignore: z.array(z.string()).default([]).describe("Array of glob patterns to be ignored from matching"),
  /** A path-to-regexp-like pattern of your content paths */
  pattern: z.string().describe("A path-to-regexp-like pattern describing your content paths")
  /** The desired type of tracking for this content */
});
const FileSchema = z.discriminatedUnion("type", [
  BaseFileSchema.extend({
    type: z.literal("universal")
  }),
  BaseFileSchema.extend({
    type: z.literal("dictionary"),
    optionalKeys: OptionalKeysSchema.optional()
  })
]);
const LocaleSchema = z.object({
  /** The label of the locale to show in the status dashboard, e.g. `"English"`, `"Português"`, or `"Español"` */
  label: z.string().describe(
    'The label of the locale to show in the status dashboard, e.g. `"English"`, `"Portugu\xEAs"`, or `"Espa\xF1ol"`'
  ),
  /** The BCP-47 tag of the locale, both to use in smaller widths and to differentiate regional variants, e.g. `"en-US"` (American English) or `"en-GB"` (British English) */
  lang: z.string().describe(
    'The BCP-47 tag of the locale, both to use in smaller widths and to differentiate regional variants, e.g. `"en-US"` (American English) or `"en-GB"` (British English)'
  )
});
const LunariaConfigSchema = z.object({
  /** The location of your Lunaria JSON schema */
  $schema: z.string().optional().describe("The location of your Lunaria JSON schema"),
  /** Options about your generated dashboard */
  dashboard: DashboardSchema.describe("Options about your generated dashboard"),
  /** Information about your project's repository */
  repository: RepositorySchema.describe("Information about your project's repository"),
  /** The default locale of your content that is going to be localized */
  defaultLocale: LocaleSchema.describe(
    "The default locale of your content that is going to be localized"
  ),
  /** Array of the localized locales */
  locales: z.array(LocaleSchema).nonempty().describe("Array of the localized locales").refine(
    (locales) => {
      const allLangs = locales.map(({ lang }) => lang);
      return allLangs.length === new Set(allLangs).size;
    },
    {
      message: "All locales should have a unique `lang` value"
    }
  ),
  /** Array of files to be tracked */
  files: z.array(FileSchema).nonempty().describe("Array of files to be tracked"),
  /** Array of commit keywords that avoid a commit from triggering status changes */
  ignoreKeywords: z.array(z.string()).default(["lunaria-ignore", "fix typo"]).describe("Array of commit keywords that avoid a commit from triggering status changes"),
  /** Name of the frontmatter property used to mark a file as localizable
   * and include it as part of the status dashboard. Keep empty for every file to be unconditionally localizable
   */
  localizableProperty: z.string().optional().describe(
    "Name of the frontmatter property used to mark a file as ready for localization. Keep empty for every file to be unconditionally localizable"
  ),
  /** The relative directory path of where your dashboard will build to, e.g. `"./dist/lunaria"` */
  outDir: z.string().default("./dist/lunaria").describe(
    'A relative directory path of where your dashboard will build to, e.g. `"./dist/lunaria"`'
  ),
  /** The relative directory path of your git history clone, exclusively made when running on a shallow repository, e.g. `"./dist/lunaria/history"` */
  cloneDir: z.string().default("./node_modules/.cache/lunaria/history").describe(
    'The relative directory path of your git history clone, exclusively made when running on a shallow repository, e.g. `"./dist/lunaria/history"`'
  ),
  /** The relative path to a valid `.(c/m)js` or `.(c/m)ts` file containing your dashboard renderer configuration */
  renderer: z.string().optional().describe(
    "The relative path to a valid `.(c/m)js` or `.(c/m)ts` file containing your dashboard renderer configuration"
  )
});
const BaseComponent = z.custom().optional();
const StatusComponent = z.custom().optional();
const LunariaRendererConfigSchema = z.object({
  slots: z.object({
    head: BaseComponent,
    beforeTitle: BaseComponent,
    afterTitle: BaseComponent,
    afterStatusByLocale: BaseComponent,
    afterStatusByFile: BaseComponent
  }).default({}),
  overrides: z.object({
    meta: BaseComponent,
    body: StatusComponent,
    statusByLocale: StatusComponent,
    statusByFile: StatusComponent
  }).default({})
});

async function loadConfig(path) {
  if (/\.json$/.test(path)) {
    try {
      const userConfig = validateConfig(readConfig(path));
      const rendererConfig = await loadRendererConfig(userConfig.renderer);
      return { userConfig, rendererConfig };
    } catch (e) {
      console.error(error("Failed to load Lunaria config\n"));
      throw e;
    }
  }
  console.error(error("Invalid Lunaria config extension, expected .json"));
  process.exit(1);
}
async function loadRendererConfig(path) {
  if (!path)
    return void 0;
  if (/\.(c|m)?(js|ts)$/.test(path)) {
    try {
      const rawConfig = await loadWithJiti(path);
      const rendererConfig = validateRendererConfig(rawConfig);
      return rendererConfig;
    } catch (e) {
      console.error(error("Failed to load Lunaria renderer config\n"));
      throw e;
    }
  }
  console.error(error("Invalid Lunaria renderer config extension, expected .(c/m)js or .(c/m)ts"));
  process.exit(1);
}
function validateConfig(config) {
  const parsedConfig = parseWithFriendlyErrors(
    LunariaConfigSchema,
    config,
    "Invalid Lunaria config:\n"
  );
  return parsedConfig;
}
function validateRendererConfig(config) {
  const parsedConfig = parseWithFriendlyErrors(
    LunariaRendererConfigSchema,
    config,
    "Invalid Lunaria renderer config:\n"
  );
  return parsedConfig;
}
function readConfig(path) {
  const resolvedPath = resolve(path);
  if (/\.json$/.test(resolvedPath)) {
    try {
      const configString = readFileSync(resolvedPath, "utf-8");
      return JSON.parse(configString);
    } catch (e) {
      console.error(error("Failed to write Lunaria config\n"));
      throw e;
    }
  }
  console.error(error("Invalid Lunaria config extension, expected .json"));
  process.exit(1);
}
function writeConfig(path, config) {
  const resolvedPath = resolve(path);
  if (/\.json$/.test(resolvedPath)) {
    try {
      const configString = JSON.stringify(config, null, 2);
      writeFileSync(resolvedPath, configString);
      return;
    } catch (e) {
      console.error(error("Failed to write Lunaria config\n"));
      throw e;
    }
  }
  console.error(error("Invalid Lunaria config extension, expected .json"));
  process.exit(1);
}
function parseWithFriendlyErrors(schema, input, message) {
  const parsedConfig = schema.safeParse(input, { errorMap });
  if (!parsedConfig.success) {
    console.error(
      error(message + parsedConfig.error.issues.map((i) => `- ${i.message}`).join("\n"))
    );
    process.exit(1);
  }
  return parsedConfig.data;
}

export { LunariaConfigSchema, LunariaRendererConfigSchema, OptionalKeysSchema, loadConfig, loadRendererConfig, parseWithFriendlyErrors, readConfig, validateConfig, validateRendererConfig, writeConfig };
